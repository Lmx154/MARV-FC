//! SX1262 LoRa Transceiver Driver (Radio)
//!
//! Incremental implementation following `docs/sx1262.md` plan.
//! This file currently provides:
//! - Struct definition holding SPI + control GPIO pins
//! - Mode & Error enums
//! - Basic config struct
//! - Constructor + placeholder SPI command method (no real hardware I/O yet)
//! - Simple `probe_status` method returning a dummy status until Step 3 adds real reset + BUSY logic
//!
//! NOTE: Pins will be wired in future steps. For now we use generic embedded-hal traits.

#![allow(dead_code)]

use embedded_hal::digital::{InputPin, OutputPin};
use embedded_hal::spi::SpiBus;
use defmt::{debug, info, warn, trace};

// Gated high-volume logging (enable with cargo feature `sx1262-verbose`).
#[cfg(feature = "sx1262-verbose")]
macro_rules! sx_trace { ($($t:tt)*) => { trace!($($t)*); }; }
#[cfg(not(feature = "sx1262-verbose"))]
macro_rules! sx_trace { ($($t:tt)*) => {}; }
#[cfg(feature = "sx1262-verbose")]
macro_rules! sx_debug { ($($t:tt)*) => { debug!($($t)*); }; }
#[cfg(not(feature = "sx1262-verbose"))]
macro_rules! sx_debug { ($($t:tt)*) => {}; }

/// SX1262 known operating modes (subset; expanded later)
#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
pub enum Sx1262Mode {
    Unknown,
    Sleep,
    StandbyRc,
    StandbyXosc,
    Fs,
    Rx,
    Tx,
    Cad,
}

/// Driver error conditions
#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
pub enum Sx1262Error {
    BusyTimeout,
    Spi,
    InvalidParam,
    InvalidTransition { from: Sx1262Mode, to: Sx1262Mode },
    StatusError(u8),
    TxTimeout,
}

pub type Result<T> = core::result::Result<T, Sx1262Error>;

/// Configuration parameters (will expand later for modulation, power etc.)
#[derive(Copy, Clone, Debug)]
pub struct Sx1262Config {
    pub use_dcdc: bool,
    pub tcxo_ctrl: bool,
    // Enable external TCXO via DIO3 control (most HF modules have a TCXO)
    pub tcxo_enable: bool,
    // TCXO voltage code (datasheet mapping: 0=1.6V .. 7=3.3V); Core1262-HF TCXO is 1.6V level
    pub tcxo_voltage_code: u8,
    // TCXO startup delay in ms (converted to ~15.625us units internally). Conservative default 5ms
    pub tcxo_delay_ms: u16,
    pub xtal_freq_hz: u32,
    // LoRa modulation defaults (Step 6)
    pub lora_sf: LoRaSpreadingFactor,
    pub lora_bw: LoRaBandwidth,
    pub lora_cr: LoRaCodingRate,
    pub lora_ldro: bool,
    pub preamble_len: u16,
    pub explicit_header: bool,
    pub payload_len: u8,
    pub crc_on: bool,
    pub invert_iq: bool,
    pub pa_duty_cycle: u8, // 0x00..0x07 typical 0x04
    pub pa_hp_max: u8,     // 0x00..0x07 typical 0x07 for +22dBm path
    pub tx_power: i8,      // -3..22 dBm for SX1262
    pub tx_ramp: TxRamp,   // ramp time enum
    // LoRa sync word (public network default 0x34). Written to Reg 0x0740/0x0741.
    pub lora_sync_word: u16,
}
impl Default for Sx1262Config {
    fn default() -> Self { Self {
        use_dcdc: true,       // Enable DC-DC path for PA efficiency
        tcxo_ctrl: false,
        tcxo_enable: true,
    tcxo_voltage_code: 0x02, // 1.8V TCXO supply (Core1262-HF module)
        tcxo_delay_ms: 10,    // longer startup guard (10ms)
        xtal_freq_hz: 32_000_000,
        lora_sf: LoRaSpreadingFactor::Sf7,
        lora_bw: LoRaBandwidth::Bw125,
        lora_cr: LoRaCodingRate::Cr45,
        lora_ldro: false,
    preamble_len: 32,     // Increased for easier RX acquisition during tests
        explicit_header: true,
        payload_len: 0, // will set later when known
        crc_on: true,
        invert_iq: false,
        pa_duty_cycle: 0x04,
        pa_hp_max: 0x07,
        tx_power: 14,
        tx_ramp: TxRamp::Us200,
    lora_sync_word: 0x3444, // Semtech public LoRa network sync word (16-bit form for SX126x)
    } }
}

// --------------- Step 6 Enumerations -----------------
#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
pub enum LoRaSpreadingFactor { Sf5=5, Sf6=6, Sf7=7, Sf8=8, Sf9=9, Sf10=10, Sf11=11, Sf12=12 }
impl LoRaSpreadingFactor { fn param(self)->u8 { self as u8 } }

#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
pub enum LoRaBandwidth {
    Bw7_81, Bw10_42, Bw15_63, Bw20_83, Bw31_25, Bw41_67, Bw62_5, Bw125, Bw250, Bw500
}
impl LoRaBandwidth {
    fn param(self)->u8 { match self { Self::Bw7_81=>0x00, Self::Bw10_42=>0x01, Self::Bw15_63=>0x02, Self::Bw20_83=>0x03, Self::Bw31_25=>0x04, Self::Bw41_67=>0x05, Self::Bw62_5=>0x06, Self::Bw125=>0x07, Self::Bw250=>0x08, Self::Bw500=>0x09 } }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
pub enum LoRaCodingRate { Cr45, Cr46, Cr47, Cr48 }
impl LoRaCodingRate { fn param(self)->u8 { match self { Self::Cr45=>0x01, Self::Cr46=>0x02, Self::Cr47=>0x03, Self::Cr48=>0x04 } } }

#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
pub enum TxRamp { Us10, Us20, Us40, Us80, Us160, Us200, Us240, Us300 }
impl TxRamp { fn param(self)->u8 { match self { Self::Us10=>0x00, Self::Us20=>0x01, Self::Us40=>0x02, Self::Us80=>0x03, Self::Us160=>0x04, Self::Us200=>0x05, Self::Us240=>0x06, Self::Us300=>0x07 } } }

/// SX1262 driver object
pub struct Sx1262<SPI, NSS, RESET, BUSY, DIO1, DIO2>
where
    NSS: OutputPin,
    RESET: OutputPin,
    BUSY: InputPin,
    DIO1: InputPin,
    DIO2: InputPin,
{
    spi: SPI,
    nss: NSS,
    reset: RESET,
    busy: BUSY,
    dio1: DIO1,
    dio2: DIO2,
    // External RF switch lines removed – module uses internal DIO2 RF switch control
    cfg: Sx1262Config,
    mode: Sx1262Mode,
    last_sleep_warm: bool,
    tx_active: bool,
    tx_start_loops: u32,
    rx_active: bool,
    rx_loops: u32,
}

#[derive(Copy, Clone, Debug, defmt::Format)]
struct StatusFields {
    raw: u8,
    chip_mode_bits: u8,
    cmd_status_bits: u8,
    mode: Sx1262Mode,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq, defmt::Format)]
enum CommandStatus { CmdRunning, DataAvailable, CmdTimeout, CmdError, Failure, Reserved(u8) }
impl CommandStatus { fn from_bits(b: u8) -> Self { match b & 0x07 { 0x0 => Self::CmdRunning, 0x1 => Self::DataAvailable, 0x2 => Self::CmdTimeout, 0x3 => Self::CmdError, 0x4 => Self::Failure, x => Self::Reserved(x) } } }

impl<SPI, NSS, RESET, BUSY, DIO1, DIO2> Sx1262<SPI, NSS, RESET, BUSY, DIO1, DIO2>
where
    SPI: SpiBus,
    NSS: OutputPin,
    RESET: OutputPin,
    BUSY: InputPin,
    DIO1: InputPin,
    DIO2: InputPin,
{
    /// Create new driver instance. Does NOT toggle reset automatically.
    pub fn new(spi: SPI, nss: NSS, reset: RESET, busy: BUSY, dio1: DIO1, dio2: DIO2, cfg: Sx1262Config) -> Self {
        Self { spi, nss, reset, busy, dio1, dio2, cfg, mode: Sx1262Mode::Unknown, last_sleep_warm: false,
            tx_active: false, tx_start_loops: 0, rx_active: false, rx_loops: 0 }
    }

    pub fn mode(&self) -> Sx1262Mode { self.mode }

    pub fn config(&self) -> &Sx1262Config { &self.cfg }
    pub fn config_mut(&mut self) -> &mut Sx1262Config { &mut self.cfg }

    // RF switch helper methods removed – internal DIO2 auto control preferred; no external pins.

    fn wait_not_busy(&mut self, timeout_cycles: u32) -> Result<()> {
        let mut spins = 0u32;
        while self.busy.is_high().unwrap_or(true) && spins < timeout_cycles {
            cortex_m::asm::nop();
            spins = spins.wrapping_add(1);
            if spins % 1_000_000 == 0 { sx_trace!("SX1262: BUSY still high spins={}", spins); }
        }
        if spins >= timeout_cycles {
            warn!("SX1262: BusyTimeout after spins={} (timeout_cycles={})", spins, timeout_cycles);
            return Err(Sx1262Error::BusyTimeout);
        }
        Ok(())
    }

    /// Reset the radio (NRST low >100us) then poll BUSY and read status
    pub fn hardware_reset_and_status(&mut self) -> Result<u8> {
        debug!("SX1262: hardware reset begin");
        self.reset.set_low().ok();
        for _ in 0..15_000 { cortex_m::asm::nop(); } // ~>100us at 125MHz (approx)
        self.reset.set_high().ok();
        // BUSY may assert then deassert; wait until low or timeout (~10ms budget)
        self.wait_not_busy(1_250_000)?; // ~10ms worth of spins (approx)
        let status = self.get_status()?;
        info!("SX1262: post-reset status=0x{:02X} mode={:?}", status, self.mode);
        Ok(status)
    }

    fn parse_status(raw: u8) -> StatusFields {
        // Per datasheet (Table 13-76): bits6:4 = chip mode, bits3:1 = command status
        let chip_mode_bits = (raw >> 4) & 0x07; // 3 bits
        let cmd_status_bits = (raw >> 1) & 0x07; // 3 bits
        let mode = match chip_mode_bits {
            0x2 => Sx1262Mode::StandbyRc,
            0x3 => Sx1262Mode::StandbyXosc,
            0x4 => Sx1262Mode::Fs,
            0x5 => Sx1262Mode::Rx,
            0x6 => Sx1262Mode::Tx,
            0x0 | 0x1 | 0x7 => Sx1262Mode::Unknown,
            _ => Sx1262Mode::Unknown,
        };
        let cs = CommandStatus::from_bits(cmd_status_bits);
        match cs {
            CommandStatus::CmdError | CommandStatus::Failure | CommandStatus::CmdTimeout => {
                warn!("SX1262: command status issue raw=0x{:02X} cs={:?}", raw, cs)
            }
            _ => { sx_trace!("SX1262: status raw=0x{:02X} mode_bits=0x{:X} cs={:?} mode={:?}", raw, chip_mode_bits, cs, mode); },
        }
        StatusFields { raw, chip_mode_bits, cmd_status_bits, mode }
    }

    fn short_delay(&self, cycles: u32) {
        for _ in 0..cycles { cortex_m::asm::nop(); }
    }

    fn write_cmd(&mut self, opcode: u8, params: &[u8]) -> Result<()> {
        // If coming out of Sleep, we must respect tTS_Wakeup by holding NSS low BEFORE shifting the opcode.
        // Datasheet (SX1261/62) indicates: first SPI access after Sleep triggers wake-up; keep NSS low for tTS_Wakeup
        // then send command bytes. Warm start ~ 500us, cold ~ 3-5ms depending on retained regs.
        if self.mode == Sx1262Mode::Sleep {
            let warm = self.last_sleep_warm;
            let delay_cycles = if warm { 65_000 } else { 400_000 }; // ~0.5ms vs ~3.2ms @125MHz (approx)
            debug!("SX1262: wake-up hold NSS low warm={} cycles={} before cmd 0x{:02X}", warm, delay_cycles, opcode);
            self.nss.set_low().ok();
            self.short_delay(delay_cycles);
            if self.spi.write(&[opcode]).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
            if !params.is_empty() && self.spi.write(params).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
            self.nss.set_high().ok();
            // After wake, BUSY will assert; wait until clear.
            self.wait_not_busy(5_000_000)?;
        } else {
            self.wait_not_busy(2_000_000)?; // guard before command
            self.nss.set_low().ok();
            if self.spi.write(&[opcode]).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
            if !params.is_empty() && self.spi.write(params).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
            self.nss.set_high().ok();
            // Allow chip to raise BUSY immediately after CS high
            self.short_delay(200);
            self.wait_not_busy(3_000_000)?; // extended guard
        }
        // Caller may choose to read status explicitly after certain commands.
    sx_trace!("SX1262: cmd 0x{:02X} sent", opcode);
        Ok(())
    }

    fn get_status(&mut self) -> Result<u8> {
        // Some commands may leave BUSY asserted briefly; still poll first
        self.wait_not_busy(1_500_000)?;
        let mut frame = [0xC0u8, 0x00u8];
        self.nss.set_low().ok();
        if self.spi.transfer_in_place(&mut frame).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        let status = frame[1];
        let f = Self::parse_status(status);
        self.mode = f.mode;
    sx_trace!("SX1262: status raw=0x{:02X} chip_mode_bits=0x{:X} cmd_status_bits=0x{:X} decoded_mode={:?}", f.raw, f.chip_mode_bits, f.cmd_status_bits, f.mode);
        Ok(status)
    }

    // ----------- Generic read command helper (Step 7 prerequisite) -----------
    fn read_cmd<const N: usize>(&mut self, opcode: u8) -> Result<([u8; N], u8)> {
        // Use a fixed maximum buffer (opcode + status + up to 16 bytes) to avoid const generic arithmetic in array size.
        // For current usage (N<=3) this is plenty.
        assert!(N <= 16, "read_cmd N too large for fixed buffer");
        self.wait_not_busy(1_000_000)?;
        let mut temp = [0u8; 18]; // [opcode][status][data up to 16]
        temp[0] = opcode;
        // Transfer only needed length (N+2)
        let mut frame = &mut temp[..(N + 2)];
        self.nss.set_low().ok();
        if self.spi.transfer_in_place(&mut frame).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        let status = frame[1];
        let mut out = [0u8; N];
        out.copy_from_slice(&frame[2..]);
        let f = Self::parse_status(status);
        self.mode = f.mode;
        Ok((out, status))
    }

    fn set_regulator_mode(&mut self) -> Result<()> {
        // SetRegulatorMode (0x96) param: 0x01 = LDO, 0x02 = DC-DC (per common implementations)
        let mode = if self.cfg.use_dcdc { 0x02 } else { 0x01 };
        debug!("SX1262: SetRegulatorMode param=0x{:02X}", mode);
        self.write_cmd(0x96, &[mode])?;
        let _ = self.get_status();
        Ok(())
    }

    fn set_dio3_as_tcxo_ctrl(&mut self) -> Result<()> {
        // SetDio3AsTcxoCtrl (0x97): voltage (1B) + delay (3B MSB..LSB). Delay units: 15.625us.
        // Convert ms to units (approx) units = ms * 64. Use 24-bit value.
        let units: u32 = (self.cfg.tcxo_delay_ms as u32) * 64;
        let delay = units.min(0x00FF_FFFF);
        let v = self.cfg.tcxo_voltage_code & 0x07;
        let frame = [v, (delay >> 16) as u8, (delay >> 8) as u8, delay as u8];
        info!("SX1262: SetDio3AsTcxoCtrl voltage_code={} delay_ms={} units=0x{:06X}", v, self.cfg.tcxo_delay_ms, delay);
        self.write_cmd(0x97, &frame)?; let _= self.get_status(); Ok(())
    }

    fn calibrate(&mut self) -> Result<()> {
        // Calibrate (0x89) mask bits: RC64K|RC13M|PLL|ADC_PULSE|ADC_BULK_N|ADC_BULK_P|IMG = 0b0111_1111 (0x7F)
        // We'll follow by CalibrateImage separately so including IMG here is optional; keep for simplicity.
        let mask = 0x7Fu8;
        debug!("SX1262: Calibrate mask=0x{:02X}", mask);
        self.write_cmd(0x89, &[mask])?; let _= self.get_status(); Ok(())
    }

    fn calibrate_image(&mut self, frequency_hz: u32) -> Result<()> {
        // CalibrateImage (0x98) takes two bytes depending on frequency band.
        // For US915 (902-928 MHz) typical pair: 0xE1, 0xE9. For 863-870: 0xD7, 0xDB. We'll pick based on freq.
        let (b1, b2) = if (902_000_000..=928_000_000).contains(&frequency_hz) {
            (0xE1, 0xE9)
        } else if (863_000_000..=870_000_000).contains(&frequency_hz) {
            (0xD7, 0xDB)
        } else {
            warn!("SX1262: CalibrateImage unknown band freq={}Hz using default 915MHz pair", frequency_hz);
            (0xE1, 0xE9)
        };
        debug!("SX1262: CalibrateImage bytes=0x{:02X} 0x{:02X}", b1, b2);
        self.write_cmd(0x98, &[b1, b2])?; let _= self.get_status(); Ok(())
    }

    fn set_packet_type_lora(&mut self) -> Result<()> {
        // SetPacketType (0x8A) param 0x01 = LoRa
        debug!("SX1262: SetPacketType LoRa");
        self.write_cmd(0x8A, &[0x01])?; let _= self.get_status(); Ok(())
    }

    fn set_rf_frequency(&mut self, freq_hz: u32) -> Result<()> {
        // SetRfFrequency (0x86) expects 4 bytes: freq = (freq_hz * 2^25)/32e6
        let raw: u32 = (((freq_hz as u64) << 25) / 32_000_000u64) as u32;
        let bytes = raw.to_be_bytes();
        debug!("SX1262: SetRfFrequency freq={}Hz raw=0x{:08X}", freq_hz, raw);
        self.write_cmd(0x86, &bytes)?; let _= self.get_status(); Ok(())
    }

    fn enable_dio2_rf_switch(&mut self) -> Result<()> {
        // SetDio2AsRfSwitchCtrl (0x9D) param: 0x01 enable
        debug!("SX1262: Enable DIO2 RF switch ctrl");
        let before = self.dio2.is_high().unwrap_or(false);
        self.write_cmd(0x9D, &[0x01])?; let st = self.get_status().unwrap_or(0);
        let after = self.dio2.is_high().unwrap_or(false);
        info!("SX1262: DIO2 RF switch enable pin_before={} pin_after={} status=0x{:02X}", before, after, st);
        Ok(())
    }

    // ---------------- Step 7: Transmission Path ----------------
    // IRQ bit masks (aligned with SX1262 datasheet Table 13-35)
    // NOTE previous mapping had HEADER_ERR/CRC_ERR swapped leading to false CRC error reports.
    const IRQ_TX_DONE: u16 = 0x0001;              // TxDone
    const IRQ_RX_DONE: u16 = 0x0002;              // RxDone
    const IRQ_PREAMBLE_DETECTED: u16 = 0x0004;    // PreambleDetected
    const IRQ_SYNC_WORD_VALID: u16 = 0x0008;      // SyncWordValid (not always used for LoRa but keep for completeness)
    const IRQ_HEADER_VALID: u16 = 0x0010;         // HeaderValid
    const IRQ_HEADER_ERR: u16 = 0x0020;           // HeaderErr
    const IRQ_CRC_ERR: u16 = 0x0040;              // CrcErr
    const IRQ_TIMEOUT: u16 = 0x0100;              // RxTxTimeout

    // ---------------- Step 8: Reception Path (non-blocking) ----------------
    pub fn start_rx_continuous(&mut self) -> Result<()> {
        if self.rx_active { return Err(Sx1262Error::InvalidParam); }
        // Ensure we enter from a clean Standby(Xosc) for best RX timing / PLL stability
        if self.mode != Sx1262Mode::StandbyXosc { self.set_standby(true)?; }
        // For continuous RX we allow any inbound length up to full FIFO; with explicit header the
        // transmitted length is carried in header, but some silicon revisions still consult the
        // configured payload length field. Set it to max (255) before arming RX to avoid length
        // filtering on default 0 value.
        self.cfg.payload_len = 255;
        let _ = self.set_lora_packet_params(); // ignore error if still warming up
        // Align TX/RX base addresses (mirror TX path convention 0x00 / 0x80)
        let _ = self.set_buffer_base_address(0x00, 0x80);
    // External RF switch control removed (DIO2 internal auto-switch on module)
        // Clear existing IRQs then arm RX-related ones (broad mask for diagnostics)
        self.clear_irq_status(0xFFFF)?;
        let irq_mask = Self::IRQ_RX_DONE
            | Self::IRQ_TIMEOUT
            | Self::IRQ_PREAMBLE_DETECTED
            | Self::IRQ_HEADER_VALID
            | Self::IRQ_HEADER_ERR
            | Self::IRQ_CRC_ERR;
        // Route all enabled to DIO1
        self.set_dio_irq_params(irq_mask, irq_mask)?;
        // Put radio into continuous RX (timeout=0xFFFFFF)
        let dio2_pre = self.dio2.is_high().unwrap_or(false);
        debug!("SX1262: pre-SetRx dio2_pin={}", dio2_pre);
        self.set_rx(0xFFFFFF)?;
        let dio2_post = self.dio2.is_high().unwrap_or(false);
        debug!("SX1262: post-SetRx dio2_pin={}", dio2_post);
        self.rx_active = true;
        self.rx_loops = 0;
        info!("SX1262: start_rx_continuous armed mode={:?}", self.mode);
        Ok(())
    }

    pub fn poll_rx(&mut self, buf: &mut [u8]) -> Result<Option<RxReport>> {
        if !self.rx_active { return Ok(None); }
        let irq = self.get_irq_status()?;
        if irq == 0 { // nothing yet
            self.rx_loops = self.rx_loops.wrapping_add(1);
            if self.rx_loops % 400_000 == 0 { let _ = self.get_status(); sx_trace!("SX1262: poll_rx loops={} mode={:?} irq=0x{:04X}", self.rx_loops, self.mode, irq); }
            return Ok(None);
        }
        // Terminal or partial events: capture snapshot
        let preamble = (irq & Self::IRQ_PREAMBLE_DETECTED) != 0;
        let header_valid = (irq & Self::IRQ_HEADER_VALID) != 0;
        let header_err = (irq & Self::IRQ_HEADER_ERR) != 0;
        let crc_err = (irq & Self::IRQ_CRC_ERR) != 0;
        let rx_done = (irq & Self::IRQ_RX_DONE) != 0;
        let timeout = (irq & Self::IRQ_TIMEOUT) != 0;
        let mut len = 0u8;
        if rx_done && !crc_err && !header_err {
            if let Ok((l, start)) = self.get_rx_buffer_status() { 
                len = l;
                let copy_len = core::cmp::min(len as usize, buf.len());
                if copy_len > 0 {
                    let mut temp = &mut buf[..copy_len];
                    if let Ok(_r) = self.read_buffer(start, &mut temp) { /* filled */ }
                }
            }
        }
        let pkt_status = self.get_packet_status().unwrap_or([0;3]);
        self.clear_irq_status(irq)?; // clear only those that fired
        // For continuous mode we keep rx_active; if timeout fired we can restart or leave decision to caller.
        if rx_done || timeout || header_err || crc_err {
            // Provide one-shot report
            let report = RxReport { irq_status: irq, rx_done, timeout, preamble_detected: preamble, header_valid, header_err, crc_err, payload_len: len, packet_status: pkt_status };
            if rx_done || timeout { // treat as session boundary
                self.rx_active = false;
            }
            info!("SX1262: poll_rx event irq=0x{:04X} rx_done={} timeout={} len={} header_err={} crc_err={}", irq, rx_done, timeout, len, header_err, crc_err);
            return Ok(Some(report));
        }
        Ok(None)
    }

    fn set_buffer_base_address(&mut self, tx_base: u8, rx_base: u8) -> Result<()> {
        debug!("SX1262: SetBufferBaseAddress tx=0x{:02X} rx=0x{:02X}", tx_base, rx_base);
        self.write_cmd(0x8F, &[tx_base, rx_base])?; let _ = self.get_status(); Ok(())
    }

    fn write_buffer(&mut self, offset: u8, data: &[u8]) -> Result<()> {
        if data.len() > 255 { return Err(Sx1262Error::InvalidParam); }
        debug!("SX1262: WriteBuffer offset=0x{:02X} len={}", offset, data.len());
        self.wait_not_busy(1_000_000)?;
        self.nss.set_low().ok();
        if self.spi.write(&[0x0E, offset]).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        if !data.is_empty() && self.spi.write(data).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        self.wait_not_busy(2_000_000)?;
        Ok(())
    }

    // ---------------- Step 8 (RX helpers – part 1) ----------------
    fn get_rx_buffer_status(&mut self) -> Result<(u8,u8)> {
        // GetRxBufferStatus (0x13) returns: payloadLength (1B), rxStartBufferPointer (1B)
        // Datasheet shows additional status byte in some diagrams; command reply here is 2 data bytes.
        let (bytes, _status) = self.read_cmd::<2>(0x13)?;
        let len = bytes[0];
        let start = bytes[1];
    sx_trace!("SX1262: GetRxBufferStatus len={} start=0x{:02X}", len, start);
        Ok((len, start))
    }

    fn read_buffer(&mut self, offset: u8, out: &mut [u8]) -> Result<usize> {
        // ReadBuffer (0x1E) sequence (per datasheet): NSS low, send 0x1E, send offset, send dummy 0x00, then clock out N bytes (dummy 0x00 each).
        // We cap at out.len(). Caller can use get_rx_buffer_status() first to know required length.
        let len = out.len().min(255);
        if len == 0 { return Ok(0); }
        self.wait_not_busy(1_000_000)?;
        self.nss.set_low().ok();
        // Preamble of command
        if self.spi.write(&[0x1E, offset, 0x00]).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        // Prepare a temp window to read into (embedded-hal SpiBus require transfer_in_place pattern)
        // We'll read in chunks to avoid large stack usage if len big; but len<=255 small enough for single buffer.
        let mut buf = &mut out[..len];
        // Fill with zeros so transfer clocks out bytes
        for b in buf.iter_mut() { *b = 0; }
        if self.spi.transfer_in_place(&mut buf).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        self.wait_not_busy(1_000_000)?;
    sx_trace!("SX1262: ReadBuffer offset=0x{:02X} len={} first_byte=0x{:02X}", offset, len, out[0]);
        Ok(len)
    }

    // ---------------- Step 9 utilities: register and error access ----------------
    pub fn write_register(&mut self, addr: u16, data: &[u8]) -> Result<()> {
        if data.is_empty() { return Ok(()); }
        debug!("SX1262: WriteRegister addr=0x{:04X} len={}", addr, data.len());
        self.wait_not_busy(1_000_000)?;
        self.nss.set_low().ok();
        let prefix = [0x0D, (addr >> 8) as u8, addr as u8];
        if self.spi.write(&prefix).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        if self.spi.write(data).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        self.wait_not_busy(1_000_000)?;
        Ok(())
    }

    pub fn read_register(&mut self, addr: u16, out: &mut [u8]) -> Result<usize> {
        if out.is_empty() { return Ok(0); }
        let len = out.len();
        debug!("SX1262: ReadRegister addr=0x{:04X} len={}", addr, len);
        self.wait_not_busy(1_000_000)?;
        self.nss.set_low().ok();
        // Opcode 0x1D + addr MSB, LSB + dummy 0x00 then read len bytes
        let header = [0x1D, (addr >> 8) as u8, addr as u8, 0x00];
        if self.spi.write(&header).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        // Fill buffer with zeros and transfer in place
        for b in out.iter_mut() { *b = 0; }
        if self.spi.transfer_in_place(out).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        self.wait_not_busy(1_000_000)?;
    sx_trace!("SX1262: ReadRegister first=0x{:02X}", out[0]);
        Ok(len)
    }

    pub fn get_device_errors(&mut self) -> Result<DeviceErrors> {
        // GetDeviceErrors (0x17) returns 2 bytes (according to ref driver). We'll capture them.
        let (bytes, _status) = self.read_cmd::<2>(0x17)?;
        let errs = DeviceErrors::from_raw(bytes[0], bytes[1]);
    sx_trace!("SX1262: DeviceErrors raw=0x{:02X} 0x{:02X}", bytes[0], bytes[1]);
        Ok(errs)
    }

    pub fn clear_device_errors(&mut self) -> Result<()> {
        debug!("SX1262: ClearDeviceErrors");
        self.write_cmd(0x07, &[])?; Ok(())
    }

    pub fn sample_status(&mut self) -> Result<StatusSnapshot> {
        let st = self.get_status()?;
        let irq = self.get_irq_status().unwrap_or(0);
        let dev_err = self.get_device_errors().unwrap_or(DeviceErrors { raw1: 0, raw2: 0, pll_lock: false, rc64k: false, rc13m: false, adc_calib: false, img_calib: false, xosc_start: false });
        let dio1 = self.dio1.is_high().unwrap_or(false);
        Ok(StatusSnapshot { status_raw: st, mode: self.mode, irq_status: irq, device_errors: dev_err, dio1_high: dio1 })
    }

    fn clear_irq_status(&mut self, mask: u16) -> Result<()> {
        let b = mask.to_be_bytes();
    sx_trace!("SX1262: ClrIrqStatus mask=0x{:04X}", mask);
        self.write_cmd(0x02, &b)?; Ok(())
    }

    fn get_irq_status(&mut self) -> Result<u16> {
        let (bytes, _status) = self.read_cmd::<2>(0x12)?; // GetIrqStatus
        let val = u16::from_be_bytes(bytes);
    sx_trace!("SX1262: GetIrqStatus=0x{:04X}", val);
        Ok(val)
    }

    fn set_dio_irq_params(&mut self, irq_mask: u16, dio1_mask: u16) -> Result<()> {
        // SetDioIrqParams (0x08): IrqMask(2) Dio1Mask(2) Dio2Mask(2) Dio3Mask(2)
        let frame = [
            (irq_mask >> 8) as u8, irq_mask as u8,
            (dio1_mask >> 8) as u8, dio1_mask as u8,
            0x00, 0x00, // DIO2 off (RF switch already controlled separately)
            0x00, 0x00, // DIO3 not wired
        ];
        debug!("SX1262: SetDioIrqParams irq_mask=0x{:04X} dio1_mask=0x{:04X}", irq_mask, dio1_mask);
        self.write_cmd(0x08, &frame)?; Ok(())
    }

    fn get_packet_status(&mut self) -> Result<[u8; 3]> {
        // For LoRa: returns RSSI pkt, SNR pkt, Signal RSSI (signed semantics later)
        let (bytes, _status) = self.read_cmd::<3>(0x14)?; // GetPacketStatus
    sx_trace!("SX1262: GetPacketStatus raw={:02X}:{:02X}:{:02X}", bytes[0], bytes[1], bytes[2]);
        Ok(bytes)
    }

    /// Blocking transmit helper (Step 7). Polls DIO1 until TxDone or timeout.
    pub fn tx_send_blocking(&mut self, payload: &[u8]) -> Result<TxReport> {
        info!("SX1262: Step 7 TX start len={} mode_before={:?}", payload.len(), self.mode);
        if payload.len() > 255 { return Err(Sx1262Error::InvalidParam); }
        // Ensure standby before TX attempt
        if self.mode != Sx1262Mode::StandbyRc && self.mode != Sx1262Mode::StandbyXosc {
            debug!("SX1262: forcing Standby before TX (mode={:?})", self.mode);
            self.set_standby(false)?; // RC standby is fine
        }
        // Update payload length in config and reapply packet params (header & CRC unchanged)
        self.cfg.payload_len = payload.len() as u8;
        self.set_lora_packet_params()?; // updates length
        self.set_buffer_base_address(0x00, 0x80)?; // separate RX base
        self.write_buffer(0x00, payload)?;
        // Clear & arm IRQs
        self.clear_irq_status(0xFFFF)?;
        let irq_mask = Self::IRQ_TX_DONE | Self::IRQ_TIMEOUT;
        self.set_dio_irq_params(irq_mask, irq_mask)?;
        // Kick TX (symbol timeout=0 -> single packet)
        self.set_tx(0x000000)?;
        // Short guard delay: some modules need a few hundred us before IRQ becomes valid
        self.short_delay(40_000); // ~300us @125MHz approx
        let mut loops: u32 = 0;
        let mut last_sample: u32 = 0;
        let mut irq: u16 = 0;
        loop {
            // Poll IRQ every iteration (cheap: only two returned bytes)
            if let Ok(v) = self.get_irq_status() { irq = v; }
            if (irq & (Self::IRQ_TX_DONE | Self::IRQ_TIMEOUT)) != 0 { break; }
            // Also break if DIO1 observed high (fast path)
            if self.dio1.is_high().unwrap_or(false) { break; }
            loops = loops.wrapping_add(1);
            if loops - last_sample > 200_000 { // periodic status sampling
                last_sample = loops;
                let _ = self.get_status();
                sx_trace!("SX1262: TX wait loops={} mode={:?} irq=0x{:04X}", loops, self.mode, irq);
            }
            if loops > 10_000_000 { // shorter bound than prior attempt
                warn!("SX1262: TX polling timeout loops={} irq=0x{:04X} mode={:?}", loops, irq, self.mode);
                return Err(Sx1262Error::TxTimeout);
            }
            cortex_m::asm::nop();
        }
        // Final IRQ fetch to ensure we have terminal bits
        irq = self.get_irq_status().unwrap_or(irq);
        self.clear_irq_status(irq)?;
        let pkt = self.get_packet_status().unwrap_or([0;3]);
        let done = (irq & Self::IRQ_TX_DONE) != 0;
        let timeout = (irq & Self::IRQ_TIMEOUT) != 0;
        info!("SX1262: TX end irq=0x{:04X} tx_done={} timeout={} loops={}", irq, done, timeout, loops);
        Ok(TxReport { irq_status: irq, tx_done: done, timeout, loops, packet_status: pkt })
    }

    /// Non-blocking start of TX. Returns Ok(()) if successfully armed.
    pub fn start_tx(&mut self, payload: &[u8]) -> Result<()> {
        if self.tx_active { return Err(Sx1262Error::InvalidParam); }
        if payload.len() > 255 { return Err(Sx1262Error::InvalidParam); }
        if self.mode != Sx1262Mode::StandbyXosc { self.set_standby(true)?; }
        self.cfg.payload_len = payload.len() as u8;
        self.set_lora_packet_params()?;
        self.set_buffer_base_address(0x00, 0x80)?;
        self.write_buffer(0x00, payload)?;
        self.clear_irq_status(0xFFFF)?;
        let irq_mask = Self::IRQ_TX_DONE | Self::IRQ_TIMEOUT;
        self.set_dio_irq_params(irq_mask, irq_mask)?;
    // External RF switch control removed (DIO2 internal auto-switch on module)
        let mut echo = [0u8;1];
        if self.read_buffer(0x00, &mut echo).is_ok() { debug!("SX1262: TX echo first=0x{:02X} expected=0x{:02X}", echo[0], payload[0]); } else { warn!("SX1262: read_buffer echo failed"); }
        let busy_pre = self.busy.is_high().unwrap_or(true);
        let dio1_pre = self.dio1.is_high().unwrap_or(false);
        debug!("SX1262: pre-SetTx pins busy={} dio1={}", busy_pre, dio1_pre);
        self.set_tx(0x000000)?;
        self.short_delay(40_000);
        let busy_post = self.busy.is_high().unwrap_or(true);
        let dio1_post = self.dio1.is_high().unwrap_or(false);
        let dio2_post = self.dio2.is_high().unwrap_or(false);
        debug!("SX1262: post-SetTx pins busy={} dio1={} dio2_pin={}", busy_post, dio1_post, dio2_post);
        self.tx_active = true;
        self.tx_start_loops = 0;
        info!("SX1262: start_tx armed len={} mode={:?}", payload.len(), self.mode);
        Ok(())
    }

    /// Poll TX progress. Returns Some(report) when TX finished (done or timeout), None if ongoing.
    pub fn poll_tx(&mut self) -> Result<Option<TxReport>> {
        if !self.tx_active { return Ok(None); }
        let irq = self.get_irq_status()?;
        if (irq & (Self::IRQ_TX_DONE | Self::IRQ_TIMEOUT)) == 0 {
            self.tx_start_loops = self.tx_start_loops.wrapping_add(1);
            if self.tx_start_loops % 200_000 == 0 {
                let _ = self.get_status();
                sx_trace!("SX1262: poll_tx loops={} mode={:?} irq=0x{:04X}", self.tx_start_loops, self.mode, irq);
            }
            if self.tx_start_loops == 5_000_000 {
                let st_before = self.mode;
                let _ = self.get_status();
                warn!("SX1262: TX seems stuck (loops={} mode_before={:?}); attempting reissue of SetTx", self.tx_start_loops, st_before);
                if self.mode != Sx1262Mode::Tx {
                    let _ = self.clear_irq_status(0xFFFF);
                    let irq_mask = Self::IRQ_TX_DONE | Self::IRQ_TIMEOUT;
                    let _ = self.set_dio_irq_params(irq_mask, irq_mask);
                    let _ = self.set_tx(0x000000);
                }
            }
            if self.tx_start_loops > 12_000_000 {
                self.tx_active = false;
                self.clear_irq_status(0xFFFF).ok();
                return Err(Sx1262Error::TxTimeout);
            }
            return Ok(None);
        }
        self.tx_active = false;
        self.clear_irq_status(irq)?;
        let pkt = self.get_packet_status().unwrap_or([0;3]);
        let done = (irq & Self::IRQ_TX_DONE) != 0;
        let timeout = (irq & Self::IRQ_TIMEOUT) != 0;
        info!("SX1262: poll_tx complete irq=0x{:04X} done={} timeout={} loops={}", irq, done, timeout, self.tx_start_loops);
        Ok(Some(TxReport { irq_status: irq, tx_done: done, timeout, loops: self.tx_start_loops, packet_status: pkt }))
    }

    // ---------------- Step 6: LoRa Modulation & Packet Params ----------------
    fn set_lora_modulation_params(&mut self) -> Result<()> {
        // SetModulationParams (0x8B): SF, BW, CR, LDRO (when packet type already set to LoRa)
        // LDRO bit: 0x01 enable else 0x00
        let sf = self.cfg.lora_sf.param();
        let bw = self.cfg.lora_bw.param();
        let cr = self.cfg.lora_cr.param();
        let ldro = if self.cfg.lora_ldro { 0x01 } else { 0x00 };
        debug!("SX1262: SetModulationParams SF={:?} BW={:?} CR={:?} LDRO={}", self.cfg.lora_sf, self.cfg.lora_bw, self.cfg.lora_cr, self.cfg.lora_ldro);
        self.write_cmd(0x8B, &[sf, bw, cr, ldro])?; let _= self.get_status(); Ok(())
    }

    fn set_lora_packet_params(&mut self) -> Result<()> {
        // SetPacketParams (0x8C) LoRa: PreambleLen(2B MSB,LSB), HeaderType, PayloadLen, CRC, InvertIQ
        let pre = self.cfg.preamble_len;
        let header = if self.cfg.explicit_header { 0x00 } else { 0x01 }; // 0x00 = Explicit, 0x01 = Implicit
        let payload = self.cfg.payload_len;
        let crc = if self.cfg.crc_on { 0x01 } else { 0x00 };
        let iq = if self.cfg.invert_iq { 0x01 } else { 0x00 };
        debug!("SX1262: SetPacketParams preamble={} header_explicit={} payload_len={} crc_on={} invert_iq={}", pre, self.cfg.explicit_header, payload, self.cfg.crc_on, self.cfg.invert_iq);
        let bytes = [ (pre >> 8) as u8, pre as u8, header, payload, crc, iq ];
        self.write_cmd(0x8C, &bytes)?; let _= self.get_status(); Ok(())
    }

    fn set_pa_config(&mut self) -> Result<()> {
        // SetPaConfig (0x95): PaDutyCycle, HpMax, DeviceSel (0x00 for SX1262), Reserved(0x01)
        let duty = self.cfg.pa_duty_cycle & 0x07;
        let hp = self.cfg.pa_hp_max & 0x07;
        debug!("SX1262: SetPaConfig duty=0x{:X} hp=0x{:X}", duty, hp);
        self.write_cmd(0x95, &[duty, hp, 0x00, 0x01])?; let _= self.get_status(); Ok(())
    }

    fn set_tx_params(&mut self) -> Result<()> {
        // SetTxParams (0x8E): Power (signed but encoded as u8 two's complement?) datasheet: 2's complement allowed -3..+22 (we clamp). Ramp = param.
        let mut p = self.cfg.tx_power;
        if p < -3 { p = -3; } else if p > 22 { p = 22; }
        let power_byte = p as i8 as u8; // direct cast, device interprets range.
        let ramp = self.cfg.tx_ramp.param();
        debug!("SX1262: SetTxParams power={}dBm ramp={:?}", p, self.cfg.tx_ramp);
        self.write_cmd(0x8E, &[power_byte, ramp])?; let _= self.get_status(); Ok(())
    }

    /// Public Step 6 sequence: modulation params + packet params + PA/Tx config
    pub fn apply_lora_params(&mut self) -> Result<()> {
        info!("SX1262: Step 6 apply LoRa modulation + packet params start");
        self.set_lora_modulation_params()?;
        self.set_lora_packet_params()?;
        self.set_pa_config()?;
        self.set_tx_params()?;
        // Program LoRa sync word (two bytes at 0x0740/0x0741). Typical public=0x34, private=0x12.
        let sw = self.cfg.lora_sync_word;
        let bytes = [ (sw >> 8) as u8, sw as u8 ];
        // Some references write only a single byte (0x34) but SX1262 exposes two registers to mirror legacy behavior.
        let _ = self.write_register(0x0740, &bytes); // ignore error if early stage
        let st = self.get_status()?;
        info!("SX1262: Step 6 params applied status=0x{:02X} mode={:?}", st, self.mode);
        Ok(())
    }

    /// Public Step 4 sequence: regulator, calibrations, packet type, frequency, dio2 rf switch
    pub fn calibrate_and_configure(&mut self, freq_hz: u32) -> Result<()> {
        info!("SX1262: Step 4 calibration + base config start");
        // 1. Regulator mode first (LDO/DC-DC)
        self.set_regulator_mode()?;
        // 2. Configure TCXO (DIO3) before switching to XOSC so startup delay honored
        if self.cfg.tcxo_enable { self.set_dio3_as_tcxo_ctrl()?; }
        // 3. Enter StandbyXosc to use stable TCXO for calibration accuracy
        self.set_standby(true)?;
        // Diagnostic: capture device error bits immediately after attempting XOSC start
        if let Ok(errs) = self.get_device_errors() {
            info!("SX1262: Post-StandbyXosc device errors pll_lock={} xosc_start={} rc13m={} rc64k={} adc_calib={} img_calib={}",
                  errs.pll_lock, errs.xosc_start, errs.rc13m, errs.rc64k, errs.adc_calib, errs.img_calib);
        }
        // 4. Perform full calibrations under XOSC
        self.calibrate()?;
        self.calibrate_image(freq_hz)?;
        // 5. Set packet type + RF frequency
        self.set_packet_type_lora()?;
        self.set_rf_frequency(freq_hz)?;
        // 6. Enable DIO2 RF switch control only if requested
        if self.cfg.tcxo_ctrl { self.enable_dio2_rf_switch()?; }
        // Remain in StandbyXosc (do NOT downgrade to RC; keeps PLL context stable)
        let st = self.get_status()?; // should show StandbyXosc (0x32 mode bits)
        info!("SX1262: calibration+config complete status=0x{:02X} mode={:?}", st, self.mode);
        Ok(())
    }

    // ---------------- Step 5: Mode Transitions ----------------
    fn update_mode_from_status(&mut self) -> Result<Sx1262Mode> {
        let _ = self.get_status()?; // updates self.mode
        Ok(self.mode)
    }

    fn set_standby(&mut self, xosc: bool) -> Result<()> {
        // SetStandby (0x80) param: 0x00 = RC, 0x01 = XOSC
        let param = if xosc { 0x01 } else { 0x00 };
        debug!("SX1262: SetStandby param=0x{:02X}", param);
        self.write_cmd(0x80, &[param])?; let _= self.get_status();
        // No external RF switch to manage
        Ok(())
    }

    fn set_fs(&mut self) -> Result<()> {
        // SetFs (0xC1)
        debug!("SX1262: SetFs");
        self.write_cmd(0xC1, &[])?; let _= self.get_status();
        Ok(())
    }

    fn set_sleep(&mut self, warm_start: bool) -> Result<()> {
        // SetSleep (0x84) params: first byte bits: [7:2] reserved, bit2=WarmStart(1) else cold, bits[1:0]= retention config (keep 0 for now)
        let param = if warm_start { 0x04 } else { 0x00 };
        debug!("SX1262: SetSleep warm_start={} param=0x{:02X}", warm_start, param);
        // Sleep does not return a status via immediate GetStatus (device sleeps)
        self.wait_not_busy(2_000_000)?; // pre-guard
        self.nss.set_low().ok();
        if self.spi.write(&[0x84, param]).is_err() { self.nss.set_high().ok(); return Err(Sx1262Error::Spi); }
        self.nss.set_high().ok();
        // Datasheet warm start wake time ~ hundreds of us; just set mode Sleep now.
        self.mode = Sx1262Mode::Sleep; // Device enters sleep; can't GetStatus until wake
        self.last_sleep_warm = warm_start;
        Ok(())
    }

    fn set_rx(&mut self, timeout_syms: u32) -> Result<()> {
        // SetRx (0x82) expects 3-byte timeout; 0x000000 = single, 0xFFFFFF = continuous.
        let t = timeout_syms.min(0xFFFFFF);
        let b = [(t >> 16) as u8, (t >> 8) as u8, t as u8];
        debug!("SX1262: SetRx timeout=0x{:06X}", t);
        self.write_cmd(0x82, &b)?; let _= self.get_status();
        Ok(())
    }

    fn set_tx(&mut self, timeout_syms: u32) -> Result<()> {
        // SetTx (0x83) 3-byte timeout
        let t = timeout_syms.min(0xFFFFFF);
        let b = [(t >> 16) as u8, (t >> 8) as u8, t as u8];
        debug!("SX1262: SetTx timeout=0x{:06X}", t);
        let pre = self.get_status().unwrap_or(0);
        debug!("SX1262: pre-SetTx status=0x{:02X} mode={:?}", pre, self.mode);
        self.write_cmd(0x83, &b)?;
        let post = self.get_status().unwrap_or(0);
        debug!("SX1262: post-SetTx status=0x{:02X} mode={:?}", post, self.mode);
        if self.mode != Sx1262Mode::Tx {
            debug!("SX1262: post-SetTx not Tx (mode={:?}) retrying via FS+StandbyXosc", self.mode);
            let _ = self.set_fs();
            let _ = self.set_standby(true);
            let _ = self.write_cmd(0x83, &b);
            let _ = self.get_status();
        }
        Ok(())
    }

    /// Public helper: perform a small demo of mode transitions for Step 5
    pub fn demo_mode_transitions(&mut self) -> Result<()> {
        info!("SX1262: Step 5 mode transition demo start (->StandbyXosc ->Fs ->StandbyRc ->Sleep warm ->StandbyRc)");
        // Ensure we start from some known standby
        self.set_standby(false)?; info!("Mode after Standby(Rc) = {:?}", self.mode);
        self.set_standby(true)?;  info!("Mode after Standby(Xosc) = {:?}", self.mode);
        self.set_fs()?;           info!("Mode after FS = {:?}", self.mode);
        // Return to Standby RC again
        self.set_standby(false)?; info!("Mode after Standby(Rc) again = {:?}", self.mode);
        // Enter sleep (warm start)
        self.set_sleep(true)?;
        info!("Mode after Sleep (warm) = {:?}", self.mode);
        // Wake by SetStandby RC with added wake delay
        // First command after sleep will perform wake timing automatically in write_cmd
        self.set_standby(false)?; info!("Mode after wake Standby(Rc) = {:?}", self.mode);
        Ok(())
    }
}

/// Report returned by blocking TX helper
#[derive(Copy, Clone, Debug, defmt::Format)]
pub struct TxReport {
    pub irq_status: u16,
    pub tx_done: bool,
    pub timeout: bool,
    pub loops: u32,
    pub packet_status: [u8;3],
}

/// Report returned by RX polling
#[derive(Copy, Clone, Debug, defmt::Format)]
pub struct RxReport {
    pub irq_status: u16,
    pub rx_done: bool,
    pub timeout: bool,
    pub preamble_detected: bool,
    pub header_valid: bool,
    pub header_err: bool,
    pub crc_err: bool,
    pub payload_len: u8,
    pub packet_status: [u8;3],
}

/// Raw device error bits decoded (Step 9)
#[derive(Copy, Clone, Debug, defmt::Format)]
pub struct DeviceErrors {
    pub raw1: u8,
    pub raw2: u8,
    pub pll_lock: bool,
    pub rc64k: bool,
    pub rc13m: bool,
    pub adc_calib: bool,
    pub img_calib: bool,
    pub xosc_start: bool,
}
impl DeviceErrors {
    pub fn from_raw(b1: u8, b2: u8) -> Self {
        // Mapping approximate; adjust once confirmed with datasheet table (placeholder flags)
        Self {
            raw1: b1, raw2: b2,
            pll_lock: (b1 & 0x01) != 0,
            rc64k: (b1 & 0x02) != 0,
            rc13m: (b1 & 0x04) != 0,
            adc_calib: (b1 & 0x08) != 0,
            img_calib: (b1 & 0x10) != 0,
            xosc_start: (b1 & 0x20) != 0,
        }
    }
}

#[derive(Copy, Clone, Debug, defmt::Format)]
pub struct StatusSnapshot {
    pub status_raw: u8,
    pub mode: Sx1262Mode,
    pub irq_status: u16,
    pub device_errors: DeviceErrors,
    pub dio1_high: bool,
}

impl<SPI, NSS, RESET, BUSY, DIO1, DIO2> Sx1262<SPI, NSS, RESET, BUSY, DIO1, DIO2>
where
    SPI: SpiBus,
    NSS: OutputPin,
    RESET: OutputPin,
    BUSY: InputPin,
    DIO1: InputPin,
    DIO2: InputPin,
{
    /// Public helper to sample instantaneous DIO1 level (true=high)
    pub fn dio1_level(&mut self) -> bool { self.dio1.is_high().unwrap_or(false) }
    /// Public helper: instantaneous BUSY pin level (true=high)
    pub fn busy_level(&mut self) -> bool { self.busy.is_high().unwrap_or(true) }
    /// Convenience: perform full radio init (reset + calibrations + params)
    pub fn init_lora(&mut self, freq_hz: u32) -> Result<()> {
        self.hardware_reset_and_status()?;
        self.calibrate_and_configure(freq_hz)?;
        self.apply_lora_params()?;
        Ok(())
    }
}

// NOTE: Unit tests omitted due to no_std target; integration tests will be added later under Step 10.
