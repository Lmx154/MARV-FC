//! BMP3x (BMP388/BMP390) I2C driver (ported from Radio)
use embedded_hal::delay::DelayNs;
use embedded_hal::i2c::{I2c, SevenBitAddress};

// I2C addresses
pub const BMP388_ADDR_SDO_LOW: u8 = 0x76;
pub const BMP388_ADDR_SDO_HIGH: u8 = 0x77;
// BMP3x aliases
pub const BMP3X_ADDR_SDO_LOW: u8 = BMP388_ADDR_SDO_LOW;
pub const BMP3X_ADDR_SDO_HIGH: u8 = BMP388_ADDR_SDO_HIGH;

// Registers / constants
const REG_CHIP_ID: u8 = 0x00;
const CHIP_ID_388: u8 = 0x50;
const CHIP_ID_390: u8 = 0x60; // BMP390/BMP390L
const REG_PWR_CTRL: u8 = 0x1B;
const REG_OSR: u8 = 0x1C;
const REG_ODR: u8 = 0x1D;
const REG_CONFIG: u8 = 0x1F;
const REG_PRESS_DATA: u8 = 0x04; // P[23:0], T[23:0]
const REG_CALIB_START: u8 = 0x31;
const REG_ERR: u8 = 0x02;    // ERR_REG
const REG_STATUS: u8 = 0x03; // STATUS (drdy and cmd_rdy)
const REG_CMD: u8 = 0x7E;    // Command register (soft reset)
const CMD_SOFTRESET: u8 = 0xB6;

// Power control op mode bits are in REG_PWR_CTRL[5:4]:
// 00 = sleep, 01 = forced, 11 = normal. Use 0b11 (0x30) for normal stream.
const PWR_CTRL_NORMAL_MODE: u8 = 0x30;
const PWR_CTRL_TEMP_PRESS_EN: u8 = 0x03; // bits 1:0 enable temp+press

// Oversampling register encodings (BMP388):
// TEMP_OS pos=3 mask=0x38; code 0x00 => 1x -> (0x00 << 3) = 0x00
// PRESS_OS pos=0 mask=0x07; code 0x00 => 1x, 0x01 => 2x, ...
const OSR_TEMP_1X: u8 = 0x00;
const OSR_PRESS_1X: u8 = 0x00;
const OSR_PRESS_2X: u8 = 0x01;
// ODR codes (BMP388/BMP390):
// 0x00 => 200 Hz, 0x01 => 100 Hz, 0x02 => 50 Hz, 0x03 => 25 Hz, ...
const ODR_200HZ: u8 = 0x00;
const ODR_100HZ: u8 = 0x01;
const ODR_50HZ: u8 = 0x02;
const ODR_25HZ: u8 = 0x03;
// IIR filter coefficient: bits 2:1; 0x00 => off, 0x01 => 1, 0x02 => 2, 0x03 => 4, ... (device specific mapping)
const IIR_FILTER_OFF: u8 = 0x00;
const IIR_FILTER_COEFF_2: u8 = 0x02;

const CALIB_DATA_LEN: usize = 21;
const DATA_LEN: usize = 6;

// Internal simple debug gate
macro_rules! bmp_dbg {
	($s:expr, $($arg:tt)*) => {
		if $s.verbose { defmt::debug!($($arg)*); }
	};
}

#[derive(Clone, Copy)]
pub struct CalibData {
	pub par_t1: f64,
	pub par_t2: f64,
	pub par_t3: f64,
	pub par_p1: f64,
	pub par_p2: f64,
	pub par_p3: f64,
	pub par_p4: f64,
	pub par_p5: f64,
	pub par_p6: f64,
	pub par_p7: f64,
	pub par_p8: f64,
	pub par_p9: f64,
	pub par_p10: f64,
	pub par_p11: f64,
	pub t_lin: f64,
}

impl Default for CalibData {
	fn default() -> Self {
		Self {
			par_t1: 0.0, par_t2: 0.0, par_t3: 0.0,
			par_p1: 0.0, par_p2: 0.0, par_p3: 0.0, par_p4: 0.0,
			par_p5: 0.0, par_p6: 0.0, par_p7: 0.0, par_p8: 0.0,
			par_p9: 0.0, par_p10: 0.0, par_p11: 0.0,
			t_lin: 0.0,
		}
	}
}

#[derive(Debug)]
pub enum Error {
	I2cError,
	InvalidChipId(u8),
	Unimplemented,
}

pub struct Bmp388<D> {
	delay: D,
	address: u8,
	pub calib: CalibData,
	verbose: bool,
}

impl<D> Bmp388<D>
where
	D: DelayNs,
{
	pub fn new(delay: D, address: u8) -> Self {
		Self { delay, address, calib: CalibData::default(), verbose: false }
	}
	pub fn set_debug(&mut self, enable: bool) { self.verbose = enable; }

	fn write_reg<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C, reg: u8, val: u8) -> Result<(), Error> {
		i2c.write(self.address, &[reg, val]).map_err(|_| Error::I2cError)
	}
	fn read_reg<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C, reg: u8) -> Result<u8, Error> {
		let mut b = [0u8; 1];
		i2c.write_read(self.address, &[reg], &mut b).map_err(|_| Error::I2cError)?;
		Ok(b[0])
	}
	fn read_many<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C, reg: u8, buf: &mut [u8]) -> Result<(), Error> {
		i2c.write_read(self.address, &[reg], buf).map_err(|_| Error::I2cError)
	}

	#[inline]
	fn wait_cmd_ready<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C, mut tries: u8) -> Result<(), Error> {
		// STATUS bit4 (cmd_rdy) indicates command interface ready
		while tries > 0 {
			let s = self.read_reg(i2c, REG_STATUS)?;
			if (s & 0x10) != 0 { return Ok(()); }
			self.delay.delay_ms(1);
			tries -= 1;
		}
		defmt::warn!("BMP cmd_rdy wait timed out");
		Err(Error::I2cError)
	}

	#[inline]
	fn ensure_normal_mode<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C, retries: u8) -> Result<(), Error> {
		let mut left = retries;
		while left > 0 {
			let p = self.read_reg(i2c, REG_PWR_CTRL)?;
			if (p & PWR_CTRL_NORMAL_MODE) == PWR_CTRL_NORMAL_MODE { return Ok(()); }
			self.wait_cmd_ready(i2c, 50).ok();
			self.write_reg(i2c, REG_PWR_CTRL, PWR_CTRL_TEMP_PRESS_EN | PWR_CTRL_NORMAL_MODE)?;
			self.delay.delay_ms(10);
			left -= 1;
		}
		let p = self.read_reg(i2c, REG_PWR_CTRL).unwrap_or(0xFF);
		defmt::error!("BMP failed to latch normal mode, PWR=0x{:02X}", p);
		Err(Error::I2cError)
	}

	#[inline]
	fn mode_str(pwr: u8) -> &'static str {
		match (pwr >> 4) & 0x03 {
			0x00 => "sleep",
			0x01 => "forced",
			0x03 => "normal",
			_ => "reserved",
		}
	}

	pub fn init<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C) -> Result<(), Error> {
		// Probe with retries
		let mut retries = 5u8;
		let mut id = 0u8;
		while retries > 0 {
			id = self.read_reg(i2c, REG_CHIP_ID).unwrap_or(0xFF);
			if id == CHIP_ID_388 || id == CHIP_ID_390 { break; }
			self.delay.delay_ms(1);
			retries -= 1;
		}
		if !(id == CHIP_ID_388 || id == CHIP_ID_390) { return Err(Error::InvalidChipId(id)); }

		// Optional: soft reset for clean start
		self.write_reg(i2c, REG_CMD, CMD_SOFTRESET)?;
		self.delay.delay_ms(10);

		// Read back basic regs after reset
		let pwr0 = self.read_reg(i2c, REG_PWR_CTRL).unwrap_or(0xFF);
		let stat0 = self.read_reg(i2c, REG_STATUS).unwrap_or(0xFF);
		let model = if id == CHIP_ID_390 { "BMP390" } else { "BMP388" };
		bmp_dbg!(self, "After reset: {} CHIP_ID=0x{:02X} PWR=0x{:02X} STATUS=0x{:02X}", model, id, pwr0, stat0);

		// Clear EVENT register to handle POR detection
		let _ = self.read_reg(i2c, 0x10);
		bmp_dbg!(self, "Cleared EVENT register after POR");

		// Read calib (21 bytes from 0x31, no CRC)
		let mut calib = [0u8; CALIB_DATA_LEN];
		self.read_many(i2c, REG_CALIB_START, &mut calib)?;
		bmp_dbg!(self, "Full calib: {=[u8]:X}", calib);
		let t1 = u16::from_le_bytes([calib[0], calib[1]]) as f64;
		let t2 = i16::from_le_bytes([calib[2], calib[3]]) as f64;  // s16 per datasheet
		let t3 = (calib[4] as i8) as f64;
		let p1 = i16::from_le_bytes([calib[5], calib[6]]) as f64;
		let p2 = i16::from_le_bytes([calib[7], calib[8]]) as f64;
		let p3 = (calib[9] as i8) as f64;
		let p4 = (calib[10] as i8) as f64;
		let p5 = u16::from_le_bytes([calib[11], calib[12]]) as f64;
		let p6 = u16::from_le_bytes([calib[13], calib[14]]) as f64;
		let p7 = (calib[15] as i8) as f64;
		let p8 = (calib[16] as i8) as f64;
		let p9 = i16::from_le_bytes([calib[17], calib[18]]) as f64;
		let p10 = (calib[19] as i8) as f64;
		let p11 = (calib[20] as i8) as f64;

		// Scale per BMP388 datasheet (exact formulas from Table 22)
		self.calib.par_t1 = t1 * 256.0;
		self.calib.par_t2 = t2 / 1073741824.0;  // 2^30
		self.calib.par_t3 = t3 / 281474976710656.0;  // 2^48
		self.calib.par_p1 = (p1 - 16384.0) / 1048576.0;  // (2^14) / 2^20
		self.calib.par_p2 = (p2 - 16384.0) / 536870912.0;  // (2^14) / 2^29
		self.calib.par_p3 = p3 / 4294967296.0;  // 2^32
		self.calib.par_p4 = p4 / 137438953472.0;  // 2^37
		// Per Bosch BMP3 API float compensation: par_p5 scale is 1 / 2^-3 => divide by 0.125 => multiply by 8
		self.calib.par_p5 = p5 * 8.0;
		self.calib.par_p6 = p6 / 64.0;  // 2^6
		self.calib.par_p7 = p7 / 256.0;  // 2^8
		self.calib.par_p8 = p8 / 32768.0;  // 2^15
		self.calib.par_p9 = p9 / 281474976710656.0;  // 2^48
		self.calib.par_p10 = p10 / 281474976710656.0;  // 2^48
		self.calib.par_p11 = p11 / 36893488147419103232.0;  // 2^65
		bmp_dbg!(self, "calib t1={:?} t2={:?} t3={:?} p1={:?} p2={:?} p5={:?}", self.calib.par_t1 as f32, self.calib.par_t2 as f32, self.calib.par_t3 as f32, self.calib.par_p1 as f32, self.calib.par_p2 as f32, self.calib.par_p5 as f32);

		// Configure OSR/ODR/IIR while in sleep
		self.write_reg(i2c, REG_OSR, OSR_TEMP_1X | OSR_PRESS_1X)?;
		self.delay.delay_ms(2);
		let _osr_rb = self.read_reg(i2c, REG_OSR).unwrap_or(0xFF);
		let _status = self.read_reg(i2c, REG_STATUS).unwrap_or(0xFF);

		// Target 200 Hz
		self.write_reg(i2c, REG_ODR, ODR_200HZ)?;
		self.delay.delay_ms(2);
		let _odr_rb = self.read_reg(i2c, REG_ODR).unwrap_or(0xFF);
		let _status = self.read_reg(i2c, REG_STATUS).unwrap_or(0xFF);

		self.write_reg(i2c, REG_CONFIG, IIR_FILTER_OFF)?;
		self.delay.delay_ms(2);
		let _cfg_rb = self.read_reg(i2c, REG_CONFIG).unwrap_or(0xFF);
		let _status = self.read_reg(i2c, REG_STATUS).unwrap_or(0xFF);

		// Enable sensors in sleep, then enter normal mode
		self.wait_cmd_ready(i2c, 50)?;
		self.write_reg(i2c, REG_PWR_CTRL, PWR_CTRL_TEMP_PRESS_EN)?;
		self.delay.delay_ms(2);
		let _status = self.read_reg(i2c, REG_STATUS)?;

		self.wait_cmd_ready(i2c, 50)?;
		self.write_reg(i2c, REG_PWR_CTRL, PWR_CTRL_TEMP_PRESS_EN | PWR_CTRL_NORMAL_MODE)?;
		self.delay.delay_ms(10);
		let pwr = self.read_reg(i2c, REG_PWR_CTRL)?;
		if (pwr & PWR_CTRL_NORMAL_MODE) != PWR_CTRL_NORMAL_MODE {
			let _err = self.read_reg(i2c, REG_ERR).unwrap_or(0xFF);
			self.ensure_normal_mode(i2c, 3)?;
		}

		// Optional: Read EVENT 0x10 to clear POR if needed
		let _event = self.read_reg(i2c, 0x10)?;

		Ok(())
	}

	pub fn read_compensated<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C) -> Result<(i32, i32), Error> {
		// Poll STATUS for both temp and press data ready: bits 6 and 5
		let mut tries: u16 = 0;
		loop {
			let s = self.read_reg(i2c, REG_STATUS)?;
			if (s & 0x60) == 0x60 { break; }
			self.delay.delay_ms(2);
			tries += 1;
			if tries > 50 { return Err(Error::I2cError); }
		}

		// Burst read 6 bytes: 0x04..0x09 => P[23:0], T[23:0]
		let mut buf = [0u8; DATA_LEN];
		self.read_many(i2c, REG_PRESS_DATA, &mut buf)?;

		// Assemble little-endian 24-bit values
		let up = ((buf[2] as u32) << 16) | ((buf[1] as u32) << 8) | (buf[0] as u32);
		let ut = ((buf[5] as u32) << 16) | ((buf[4] as u32) << 8) | (buf[3] as u32);

		// Compensation
		let ut_f = ut as f64;
		let up_f = up as f64;
		let dt = ut_f - self.calib.par_t1;
		let t_lin = dt * self.calib.par_t2 + dt * dt * self.calib.par_t3;
		self.calib.t_lin = t_lin;

		let pd1 = self.calib.par_p6 * t_lin;
		let pd2 = self.calib.par_p7 * t_lin * t_lin;
		let pd3 = self.calib.par_p8 * t_lin * t_lin * t_lin;
		let out1 = self.calib.par_p5 + pd1 + pd2 + pd3;

		let pd4 = self.calib.par_p2 * t_lin;
		let pd5 = self.calib.par_p3 * t_lin * t_lin;
		let pd6 = self.calib.par_p4 * t_lin * t_lin * t_lin;
		let out2 = up_f * (self.calib.par_p1 + pd4 + pd5 + pd6);

		let pd7 = up_f * up_f;
		let pd8 = self.calib.par_p9 + self.calib.par_p10 * t_lin;
		let pd9 = pd7 * (self.calib.par_p11 + pd8);
		let p_pa = out1 + out2 + pd9;

		// no_std-friendly rounding
		let t_c_x100 = t_lin * 100.0;
		let t_i32 = if t_c_x100.is_finite() { (t_c_x100 + if t_c_x100 >= 0.0 { 0.5 } else { -0.5 }) as i32 } else { 0 };
		let p_i32f = p_pa;
		let p_i32 = if p_i32f.is_finite() { (p_i32f + if p_i32f >= 0.0 { 0.5 } else { -0.5 }) as i32 } else { 0 };

		Ok((t_i32, p_i32))
	}

	// Debug helper to dump key registers for diagnosing stale data issues
	pub fn dump_regs<I2C: I2c<SevenBitAddress>>(&mut self, i2c: &mut I2C) {
		let _chip = self.read_reg(i2c, REG_CHIP_ID).unwrap_or(0xFF);
		let _err = self.read_reg(i2c, REG_ERR).unwrap_or(0xFF);
		let _stat = self.read_reg(i2c, REG_STATUS).unwrap_or(0xFF);
		let _pwr = self.read_reg(i2c, REG_PWR_CTRL).unwrap_or(0xFF);
		let _osr = self.read_reg(i2c, REG_OSR).unwrap_or(0xFF);
		let _odr = self.read_reg(i2c, REG_ODR).unwrap_or(0xFF);
		let _cfg = self.read_reg(i2c, REG_CONFIG).unwrap_or(0xFF);
		let _event = self.read_reg(i2c, 0x10).unwrap_or(0xFF);
	}
}

// BMP3x alias type for external naming
pub type Bmp3x<D> = Bmp388<D>;
